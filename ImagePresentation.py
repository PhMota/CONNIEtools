from __future__ import print_function
from Beamer import *
import os
import subprocess
from Timer import Timer
import sys

folder = 'ImagePresentation'

if not os.path.exists(folder):
    os.mkdir(folder)

def projections_slide( name, cmd ):
    scale = .3
    contents = ['projections of the raw image', doc.code( cmd, 'Bash') ]
    contents += [ doc.figure( name+'/median_o3_{}.pdf'.format(key), scale=scale ) for key in ['dataProj1', 'dataProj0', 'biasProj', 'vbiasProj' ] ]
    doc.frame( *contents )

with Timer('presentation'):
    with openBeamer( folder ) as doc:

        name = 'median'
        fname = r'/share/storage2/connie/data/runs/*/runID_*_03326_*_p*.fits.fz'
        cmd = 'python Image.py analyse {folder}/{name} "{fname}" --ohdu 3 --plot-sections --plot-spectrum'\
            .format( name=name, fname=fname, folder=folder)
        print( cmd )
        func = lambda: subprocess.call( [cmd], shell=True )
        
        doc.set_func(func)
        doc.frame('goal', 
                #doc.code( cmd, 'Bash'),
                doc.itemize(
                    'it is essencial to have a good control of the noise and dark current of the images since they affect directly detection threshold',
                    'a good understanding of the behavior of the dark current is paramount for an efficient event extraction focusing in reducing the fake events',
                    'hardware approach using skipper CCDs is underway which promises to decrease significantly the readout noise allowing the proper identification of the dark current',
                    'I have advanced in a parallel direction: developping tools to extract the maximum information from the existing images both 1x1 and 1x5',
                )
                )

        doc.frame('goal', 
                doc.itemize(
                    'analytically, I have derived the following relations\
                    $$m_1[{\\rm DC+Noise}] = g\lambda + \mu[{\\rm Noise}] $$\
                    $$m_2[{\\rm DC+Noise}] = g^2\lambda + \sigma[{\\rm Noise}]^2 $$\
                    $$m_3[{\\rm DC+Noise}] = g^3\lambda$$                   where $m_i$ are the $i$-th moments of the Poisson-Norm distribution corrected by its first moment, $\mu$ and $\sigma$ are the parameters of the Norm noise, $\lambda$ is the Poisson rate and $g$ is the convolution shift which physically controls how many ADUs the distribution is shifted by the presence of one electron (dark current), $g$ is the charge gain',
                    'these relations are redundant and can be used to attest the quality of the estimations',
                )
                )
        doc.frame('goal', 
                doc.itemize(
                    'in practice, we have to relate these quantities with sample estimations of the data',
                    'The straightforward associations are proposed in a first glance'+
                    '$$\mu[{\\rm Noise}] = {\\rm mean}[{\\rm OS}]$$'+
                    '$$\sigma[{\\rm Noise}]^2 = {\\rm var}[{\\rm OS}]$$'+
                    '$$m_1[{\\rm DC+Noise}] = {\\rm mean}[{\\rm AC}]$$'+
                    '$$m_2[{\\rm DC+Noise}] = {\\rm var}[{\\rm AC}]$$'+
                    '$$m_3[{\\rm DC+Noise}] = {\\rm mean}(X-{\\rm mean}[{\\rm AC}])^3$$'
                    ,
                    'however, the presence of modulations and other features of the image make weaken the quality of these estimations',
                    'furthermore, the presence of the data requires a careful analysis since all these quantites will be shifted by the data'
                )
                )

        doc.frame('goal', 
                'I focus in 3 parallel ways to tackle the problem',
                doc.itemize(
                    'correcting the image',
                    'using robust estimators',
                    'energy-independent separation of data and dark current',
                )
                )

        doc.frame('tool for image analysis', 
                'I have developed an user-friendly -- ask Carla ;-) -- tool for this analysis\n',
                'in fact, this presentation is can be generated by the tool\n',
                'sample call',
                doc.code( cmd, 'Bash'),
                'other functionalities',
                doc.itemize( 'read header', 'simulate and get params', 'extract hits (next week: comparison with offical extraction)' ),
                'run locally',
                doc.code( '\n'.join(( 'git init', 'git pull https://github.com/PhMota/CONNIEtools', 'python ImagePresentation.py' )), 'Bash' )
                )
        
        
        scaleSection = .6
        optsSection = [['data',1], ['bias',1], ['vbias',.7], ['dbias',.1] ]
        figsSection = lambda name,pre,optsSection=optsSection: [ doc.figure( name+'/{}_o3_{}.pdf'.format(pre,key), scale=x*scaleSection) for key, x in optsSection ]
        doc.frame('image imperfections', 
                doc.code( cmd, 'Bash'),
                doc.column(
                    doc.center( *figsSection('median', 'median') ),
                    '1x1 raw sections\n\n'+
                    'vertical modulation is clearly visible',
                    widths = [.6,-1]
                )
                )
        
        scaleProj = .25
        optsProj = ['dataProj1', 'dataProj0', 'biasProj', 'vbiasProj']
        figsProj = lambda name, pre: [ doc.figure( name+'/{}_o3_{}.pdf'.format(pre,key), scale=scaleProj ) for key in optsProj ]
        doc.frame('projections of the raw image', 
                doc.code( cmd, 'Bash'),
                doc.column(
                    doc.center( *figsProj('median', 'median') ),
                    'vertical modulation, horizontal modulation, hot columns\n\n\n',
                    widths = [.6,-1]
                ))

        doc.frame('projections of the raw image', 
                'the MonitorViewer tool attempts to circumvent these imperfections, by estimating the quantities independently for each line and taking the mean over these results\
                $$\sigma = {\\rm mean}({\\rm MAD}[{\\rm OS}]_i)$$\
                $$g\lambda = {\\rm mean}({\\rm median}[{\\rm AC}]_i - {\\rm median}[{\\rm OS}]_i )$$\
                $$g^2\lambda = {\\rm mean}({\\rm MAD}[{\\rm AC}]_i - {\\rm MAD}[{\\rm OS}]_i )$$',
                'these quantities give consistent estimations for simulations generated with no(!) data',
                )
        scaleSpectrum = .3
        optsSpectrum = ['data', 'bias', 'vbias', 'dbias']
        figsSpectrum = lambda name, pre, kind='_spectrum': [ doc.figure( name+'/{}_o3_{}{}.pdf'.format(pre,key,kind), scale=scaleSpectrum ) for key in optsSpectrum ]
        doc.frame('spectra of the raw image', 
                doc.code( cmd, 'Bash'),
                doc.column(
                    doc.center( *figsSpectrum('median', 'median') ),
                    'however, real distributions are crowded with outliers which heavily impair the capability of accurately estimating the parameters of the distribution',
                    widths = [.7,-1]))
                

        with Timer():
            name = 'mean'
            cmd = 'python Image.py analyse {folder}/{name} "{fname}" --ohdu 3 --params-mode mean --plot-sections --plot-spectrum'\
                .format(fname=fname, folder=folder, name=name)
            print( cmd )
            func = lambda: subprocess.call( [cmd], shell=True )

            doc.set_func(func)
            
            #doc.frame('Mean outliers analysis with line and col corrections', 
                    #'bash command',
                    #doc.code( cmd, 'Bash'),
                    #'parameters',
                    #doc.center( doc.table( file=name+'/mean_params.csv', fontsize=5, spacing=6, divide=2 ) ), 
                    #)

            doc.frame('sections with line and col corrections', 
                    doc.code( cmd, 'Bash'),
                    doc.column(
                        doc.center( *figsSection('mean', 'mean') ),
                        'perform overscan subtraction by estimating the mean of the distribution line by line after removing the outliers\n then remove the vertical overscan modulation',
                        widths = [.6, -1]
                        ))
            
            doc.frame('projections with line and col corrections', 
                    doc.code( cmd, 'Bash'),
                    doc.column(
                        doc.center( *figsProj('mean','mean') ),
                        'data becomes quite stable on both lines and columns',
                        widths = [.6,-1]
                        ))
            
            doc.frame('spectra with line and col corrections', 
                    doc.code( cmd, 'Bash'),
                    doc.column( 
                        doc.center( *figsSpectrum('mean','mean') ),
                        'this proceedure over the overscans succesfully removes their outliers allowing for the use of redundant estimators to control the estimations',
                        widths = [.7,-1]
                        )
                    )


        with Timer():
            name = 'mean'
            cmd = 'python Image.py analyse {folder}/{name} "{fname}" --ohdu 3 --remove-hits 40 3 --params-mode mean --plot-sections --plot-spectrum'\
                .format(fname=fname, folder=folder, name=name)
            print( cmd )
            func = lambda: subprocess.call( [cmd], shell=True )
            doc.set_func(func)
            
            pre = 'mean_e40.0b3.0'
            
            figs = [ doc.figure( name+'/{}_o3_{}.pdf'.format(pre,key), scale=x*scaleSection) for key, x in optsSection ]
            doc.frame('removed above 40ADU with border 3',
                    doc.code( cmd, 'Bash'),
                    doc.column(
                        doc.center( *figsSection('mean', pre) ),
                        'in the data region, a cluster removal algorithm is applied',
                        widths = [.6,-1]
                        )
            )
            
            scale = .3
            noise = 14.44
            dc = 2.32
            dc2 = 15.24**2 - noise**2
            doc.frame('removed above 40ADU with border 3 spectra',
                    doc.code( cmd, 'Bash'),
                    doc.column(
                        doc.center( *figsSpectrum('mean', pre) ),
                        '$$\sigma={noise}$$\n\
                        $$g\lambda={dc}$$\n\
                        $$g^2\lambda={dc2:.2f}$$\n\
                        $$g={g:.2f}$$\n\
                        $$\lambda={lamb:.2f}$$\n'.format(noise=noise, dc=dc, dc2=dc2, g=dc2/dc, lamb=dc**2/dc2)
                        +
                        'perhaps 40ADU was too agressive since a large chunck of the Poisson-Norm distribution was also removed',
                        widths = [.7,-1]
                    )
            )
                    #thr  border noise dc
        thislist = [[60.0,   3.0, 14.4, 2.41, 15.39**2 - 14.5**2, 'values are remarkably stable even though the value for the gain is higher than $\sim 7$ expected from the independent Cu estimation' ], 
                    [80.0,   2.0, 14.4, 2.42, 15.39**2 - 14.5**2, 'values are remarkably stable, although stable does not mean correct' ],
                    [150.0,  0.0, 14.4, 2.72, 15.6**2 - 14.5**2, 'values are remarkably stable' ], 
                    [5000.0, 0.0, 14.4, 3.42, 16.3**2 - 14.5**2, 'sanity check: yes, it breaks! yupi' ]]
        for threshold, border, noise, dc, dc2, text in thislist:
            name = 'mean'
            cmd = 'python Image.py analyse {folder}/{name} "{fname}" --ohdu 3 --params-mode mean --remove-hits {threshold} {border} --plot-spectrum'\
                .format( fname=fname, folder=folder, name=name, threshold=threshold, border=border )
            print( cmd )
            func = lambda: subprocess.call( [cmd], shell=True )
            doc.set_func(func)
            pre = 'mean_e{threshold}b{border}'.format(threshold=threshold, border=border)
                            
            scale = .3
            doc.frame(
                '$E<{:.0f}$ADU (+{:.0f}) spectra'.format(threshold,border), 
                doc.code( cmd, 'Bash'),
                doc.column(
                    doc.center( *figsSpectrum('mean', pre) ),
                    'estimations\n\n\
                    $$\sigma={noise}$$\n\
                    $$g\lambda={dc}$$\n\
                    $$g^2\lambda={dc2:.2f}$$\n\
                    $$g={g:.2f}$$\n\
                    $$\lambda={lamb:.2f}$$'.format(noise=noise, dc=dc, dc2=dc2, g=dc2/dc, lamb=dc**2/dc2)
                    +
                    text,
                    widths = [.7,-1]
                )
            )
        
        #with Timer('convolution'):
            #threshold = 100.0
            #border = 3.0
            #cmd = 'python Image.py analyse {folder}/{name} "{fname}" --ohdu 3 --params-mode mean --remove-hits {threshold} {border} --plot-convolution-spectrum'\
                #.format( fname=fname, folder=folder, name=name, threshold=threshold, border=border )
            #print( cmd )
            #func = lambda: subprocess.call( [cmd], shell=True )
            #doc.set_func(func)
            
            #pre = 'mean_e{threshold}b{border}'.format(threshold=threshold, border=border)
            #thislist = [[5, 64.6, 52, 77.1],
                        #[10, 127.6, 223.3, 165.7]]
            #for n, noise, dc, dc2 in thislist:
                #dc2 = (dc2**2 - noise**2)
                #doc.frame('convolution sum {D}x{D} $E<{:.0f}$(+{:.0f})'.format(threshold,border,D=n), 
                    #doc.code( cmd, 'Bash'),
                    #doc.column(
                        #doc.center( *figsSpectrum('mean', pre, kind='_convolution%d'%n) ),
                    #'estimations\n\n\
                    #$$\sigma={noise}$$\n\
                    #$$g\lambda={dc}$$\n\
                    #$$g^2\lambda={dc2}$$\n\
                    #$$g={g:.2f}$$\n\
                    #$$\lambda={lamb:.2f}$$'.format(noise=noise, dc=dc, dc2=dc2, g=dc2/dc, lamb=dc**2/dc2),
                        #widths=[.7,-1] )
                #)

        with Timer('blocks'):
            threshold = 100.0
            border = 3.0

            gl5 = 2.54
            sig5 = 14
            g2l5 = 14.8**2-sig5**2
            
            gl10 = 2.55
            sig10 = 14.3
            g2l10 = 15.2**2-sig10**2

            blocks = [
                ['blockmean', 'np.nanmean(x)', 'mean', 5, 
                 'the previous estimation was global and relies on the homogeneity of the estimation throught the CCD. This plots show the distribution of the mean estimation for partitions of 5x5 of the image' + '$$g\lambda={}$$'.format(gl5)
                 ], 
                ['blockstd', '(lambda y: np.nan if y==0 else y)(np.nanstd(x))', 'std', 5,
                 'distribution of the stds' +
                 '$$\sigma={}$$\n$$g^2\lambda={:.0f}$$\n$$g={:.2f}$$\n$$\lambda={:.2f}$$'.format(sig5, g2l5, g2l5/gl5, gl5**2/g2l5 ) +
                 'this result can be estimated with properly calculated errorbars!\n {\\tiny dramatic pause for appreciation}'
                 ],
                ['blockmean', 'np.nanmean(x)', 'mean', 10, 
                 'sanity check, repeat the calculations for 10x10 partitions' + '$$g\lambda={}$$'.format(gl10)],
                ['blockstd', '(lambda y: np.nan if y==0 else y)(np.nanstd(x))', 'std', 10, 
                 '$$\sigma={}$$\n$$g^2\lambda={:.0f}$$\n$$g={:.2f}$$\n$$\lambda={:.2f}$$'.format(sig10, g2l10, g2l10/gl10, gl10**2/g2l10 )
                 + 'there is a dependence on the size of the partition'
                 ],
                    ]
            for _name_, _func_, funclabel, D, text in blocks:
                cmd = 'python Image.py analyse {folder}/{name} "{fname}" --ohdu 3 --params-mode mean --remove-hits {threshold} {border} --plot-block-spectrum --block-function "{_func_}"'\
                    .format( fname=fname, folder=folder, name=_name_, threshold=threshold, border=border, _func_=_func_ )
                print( cmd )
                func = lambda: subprocess.call( [cmd], shell=True )
                doc.set_func(func)
                
                pre = 'mean_e{threshold}b{border}'.format(threshold=threshold, border=border)
                doc.frame('{funclabel} block {D}x{D} $E<{:.0f}$ADU (+{:.0f})'.format(threshold,border,funclabel=funclabel,D=D), 
                    doc.code( cmd, 'Bash'),
                    doc.column(
                        doc.center( *figsSpectrum(_name_, pre, kind='_block%d'%D) ),
                        text,
                        widths=[.7,-1] ))

        with Timer('evolution'):
            threshold = 100.0
            border = 3.0
            _name_ = 'dcevo'
            cmd = 'python Image.py analyse {folder}/{name} "{fname}" --ohdu 3 --params-mode mean --remove-hits {threshold} {border} --plot-sections'\
                .format( fname=fname, folder=folder, name=_name_, threshold=threshold, border=border )
            print( cmd )
            func = lambda: subprocess.call( [cmd], shell=True )
            doc.set_func(func)
            
            pre = 'mean_e{threshold}b{border}'.format(threshold=threshold, border=border)
            doc.frame('evolution of DC through time $E<{}$ADU (+{})'.format(threshold,border), 
                doc.code( cmd, 'Bash'),
                doc.column(
                    doc.center( *figsProj('dcevo', pre ) ),
                    'the obvious question you might be making me now is: can I plot the DC for time?\n\\\\[1cm] YES!\nthere is a shift of $g\lambda=0.5$ comparing the first read line to the last and it is one order of magnitude higher than the shifts in the overscan sections. Promising!',
                    widths = [.7,-1]))
                    
        fname = r'/share/storage2/connie/data/runs/*/runID_*_12000_*_p*.fits.fz'
        with Timer():
            name = 'median1x5'
            cmd = 'python Image.py analyse {folder}/{name} "{fname}" --ohdu 3 --plot-sections --plot-spectrum'\
                .format( name=name, fname=fname, folder=folder)
            print( cmd )
            func = lambda: subprocess.call( [cmd], shell=True )
            
            scale = 1.2
            optsSection = [['data',1*scale], ['bias',.25*scale], ['vbias',1*scale], ['dbias',.15*scale] ]
            doc.frame('1x5 ', 
                    'before you ask, here is the analysis on rebinned images',
                    doc.code( cmd, 'Bash'),
                    doc.center( *figsSection(name, 'median', optsSection=optsSection) ),
                    'raw image'
                    )
            
            text = ''
            doc.frame('projections of the raw image', 
                    doc.code( cmd, 'Bash'),
                    doc.column(
                        doc.center( *figsProj(name, 'median') ),
                        'before the line and column corrections data show am interesting modulation on time and a sharp rise of baseline in the beginning of each line (this is also present in 1x1, but here it is more evident)',
                        widths=[.7,-1] ))

            text = ''
            doc.frame('spectra of the raw image', 
                    'distributions are crowded with outliers',
                    doc.code( cmd, 'Bash'),
                    doc.column(
                        doc.center( *figsSpectrum(name, 'median') ),
                        'which leads to terrible outliers in the vertical overscan. The overscan looks clean, but it is actually convoluted with a sharp modulation',
                        widths=[.7,-1] ))

        with Timer('evolution'):
            threshold = 100.0
            border = 3.0
            _name_ = 'dcevo1x5'
            cmd = 'python Image.py analyse {folder}/{name} "{fname}" --ohdu 3 --params-mode mean --remove-hits {threshold} {border} --plot-sections --plot-spectrum'\
                .format( fname=fname, folder=folder, name=_name_, threshold=threshold, border=border )
            print( cmd )
            func = lambda: subprocess.call( [cmd], shell=True )
            doc.set_func(func)

            doc.frame('1x5 spectra with line and col corrections 1x5', 
                doc.code( cmd, 'Bash'),
                doc.column(
                        doc.center( *figsSpectrum('dcevo1x5', pre, kind='_spectrum') ),
                        'the algorithm manages to succesfully correct for the vertical overscan outliers, but there is a visible bump at negative energies of the data distribution. Let us investigate!',
                        widths=[.7,-1]
                    ))
            
            pre = 'mean_e{threshold}b{border}'.format(threshold=threshold, border=border)
            doc.frame('1x5 evolution of DC $E<{}$ADU (+{})'.format(threshold,border), 
                doc.code( cmd, 'Bash'),
                doc.column(
                    doc.center( *figsProj('dcevo1x5', pre ) ),
                    'although the horizontal modulation was succesfully subtracted from the vertical overscan, the data still displays a dip. Interestingly, even in the overscan, the fluctuations collapse close to the beginning of the reading. This is not compatible with a simple baseline shift. Could this be a gain variation?!',
                    widths = [.7,1]))


        with Timer('blocks'):
            threshold = 100.0
            border = 3.0
            gl5 = 0.58
            sig5 = 14.1
            g2l5 = 14.3**2 - sig5**2
            g5 = g2l5/gl5
            
            gl10 = 0.62
            sig10 = 14.4
            g2l10 = 14.7**2 - sig10**2
            g10 = g2l10/gl10
            thislist = [
                ['blockmean1x5', 'mean', 'np.nanmean(x)',5, 'the spatial partition algorithm is robust enough to ignore the modulation'], 
                ['blockstd1x5', 'std', '(lambda y: np.nan if y==0 else y)(np.nanstd(x))',5, 
                 'estimation\n $$g\lambda={gl5}$$ $$\sigma={sig5}$$ $$g^2\lambda={g2l5:.2f}$$ $$g={g5:.2f}$$ $$\lambda={l5:.2f}$$'.format(gl5=gl5, sig5=sig5, g2l5=g2l5, g5=g5, l5=gl5/g5)
                 ],
                ['blockmean1x5', 'mean', 'np.nanmean(x)',10, 'repeating the a analysis for larger partitions'], 
                ['blockstd1x5', 'std', '(lambda y: np.nan if y==0 else y)(np.nanstd(x))',10, 
                 'estimation\n $$g\lambda={gl10}$$ $$\sigma={sig10}$$ $$g^2\lambda={g2l10:.2f}$$ $$g={g10:.2f}$$ $$\lambda={l10:.2f}$$'.format(gl10=gl10, sig10=sig10, g2l10=g2l10, g10=g10, l10=gl10/g10)
                 ],
                ]
            for _name_, label, _func_, D, text in thislist:
                cmd = 'python Image.py analyse {folder}/{name} "{fname}" --ohdu 3 --params-mode mean --remove-hits {threshold} {border} --plot-block-spectrum --block-function "{_func_}"'\
                    .format( fname=fname, folder=folder, name=_name_, threshold=threshold, border=border, _func_=_func_ )
                print( cmd )
                func = lambda: subprocess.call( [cmd], shell=True )
                doc.set_func(func)
                
                pre = 'mean_e{threshold}b{border}'.format(threshold=threshold, border=border)
                scale = .3
                doc.frame('1x5 {} block {D}x{D} $E<{}$ADU (+{})'.format(label, threshold,border,D=D), 
                doc.code( cmd, 'Bash'),
                    doc.column(
                        doc.center( *figsSpectrum(_name_, pre, kind='_block%d'%D) ),
                        text,
                        widths=[.7,-1] ))
                

        doc.frame('summary',
              doc.itemize(
                'yet another tool for analysing the data and performing simulations',
                'I believe that redundancy of tools for analysis is needed in order to reduce the chance of a major analysis mistake not to mention the constructive competition',
                'testing against simulations is zero-th order and I am working on it',
                'testing agains the official tools is next in line -- Carla\'s share of duty',
                'promising insights that are being tested against simulations, presentation next week',
                            ))
        doc.frame('summary',
              doc.itemize(
                'hypothesis: the gain overestimation is related to the vertical overscan subtraction (which contains small dark current) that ends up shifting the center of the data distribution, therefore underevaluating $g\lambda$. On the other hand, $g^2\lambda$ is unaffected by this shift and thus although a small shift for the data mean, it is a great shift for the gain!',
                'verification: not to lose the advantage of (partially) removing the horizontal modulation, I will estimate the vertical overscan shift in relation to the horizontal overscan using the half of the section not affected by the modulation. Then after the subtraction, I will reintroduce this shift',
                'there is also the correlated noise which was not treated (yet) here. The correlated noise affects the terms in different amounts and may be a source of incertainty, I plan to attempt subtracting the mirrored right side image by requiring that it maximally reduces the noise in the overscan.'
                'the partitioning analysis opens the possibility of performing spatial dc/data discrimination by estimating the spread of the partition. This is a promising approach to extract hits buried in the dark current energy range safely.'
            ))
        
        
        #Backup
        
        optsSectionR = [['dataR',1], ['biasR',1], ['vbiasR',.7], ['dbiasR',.1] ]
        doc.frame('right-side with line and col corrections', 
                doc.code( cmd, 'Bash'),
                doc.column(
                    doc.center( *figsSection('mean', 'mean', optsSectionR) ),
                    'right side',
                    widths = [.6, -1]
                    ))
              
        with Timer('blocks'):
            fname = r'/share/storage2/connie/data/runs/*/runID_*_03326_*_p*.fits.fz'
            name = 'mean'
            threshold = 100.0
            border = 3.0

            gl5 = 2.54
            sig5 = 14
            g2l5 = 14.8**2-sig5**2
            
            gl10 = 2.55
            sig10 = 14.3
            g2l10 = 15.2**2-sig10**2

            blocks = [
                ['blockmean', 'np.nanmean(x)', 'mean', 5, 
                 'the previous estimation was global and relies on the homogeneity of the estimation throught the CCD. This plots show the distribution of the mean estimation for partitions of 5x5 of the image' + '$$g\lambda={}$$'.format(gl5)
                 ], 
                ['blockstd', '(lambda y: np.nan if y==0 else y)(np.nanstd(x))', 'std', 5,
                 'distribution of the stds' +
                 '$$\sigma={}$$\n$$g^2\lambda={:.0f}$$\n$$g={:.2f}$$\n$$\lambda={:.2f}$$'.format(sig5, g2l5, g2l5/gl5, gl5**2/g2l5 ) +
                 'this result can be estimated with properly calculated errorbars!\n {\\tiny dramatic pause for appreciation}'
                 ],
                ['blockmean', 'np.nanmean(x)', 'mean', 10, 
                 'sanity check, repeat the calculations for 10x10 partitions' + '$$g\lambda={}$$'.format(gl10)],
                ['blockstd', '(lambda y: np.nan if y==0 else y)(np.nanstd(x))', 'std', 10, 
                 '$$\sigma={}$$\n$$g^2\lambda={:.0f}$$\n$$g={:.2f}$$\n$$\lambda={:.2f}$$'.format(sig10, g2l10, g2l10/gl10, gl10**2/g2l10 )
                 + 'there is a dependence on the size of the partition'
                 ],
                    ]
            for _name_, _func_, funclabel, D, text in blocks:
                cmd = 'python Image.py analyse {folder}/{name} "{fname}" --ohdu 3 --params-mode mean --remove-hits {threshold} {border} --plot-block-spectrum --block-function "{_func_}" --fix-vbias'\
                    .format( fname=fname, folder=folder, name=_name_, threshold=threshold, border=border, _func_=_func_ )
                print( cmd )
                func = lambda: subprocess.call( [cmd], shell=True )
                doc.set_func(func)
                
                pre = 'mean_vfix_e{threshold}b{border}'.format(threshold=threshold, border=border)
                doc.frame('vfix {funclabel} block {D}x{D} $E<{:.0f}$ADU (+{:.0f})'.format(threshold,border,funclabel=funclabel,D=D), 
                    doc.code( cmd, 'Bash'),
                    doc.column(
                        doc.center( *figsSpectrum(_name_, pre, kind='_block%d'%D) ),
                        text,
                        widths=[.7,-1] ))
